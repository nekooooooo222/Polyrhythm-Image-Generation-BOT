cat > bot.py << 'PY'
import discord
from discord import option
import subprocess, os, datetime, asyncio, functools, re, time, json
from dotenv import load_dotenv
import google.generativeai as genai

#--- 1. åˆæœŸè¨­å®š ---
load_dotenv()
DEBUG_PASSWORD = "polyrhythm_debug"
MAX_TUPLET_DIVISION = 3
TOKEN = os.getenv("DISCORD_BOT_TOKEN")

GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", None) 

if not TOKEN: print("ã‚¨ãƒ©ãƒ¼: DISCORD_BOT_TOKENãŒ.envã«ã‚ã‚Šã¾ã›ã‚“ã€‚"); exit()

# Geminiãƒ¢ãƒ‡ãƒ«ã®åˆæœŸåŒ–
genai_model = None
if GEMINI_API_KEY:
    try:
        genai.configure(api_key=GEMINI_API_KEY)
        genai_model = genai.GenerativeModel('gemini-2.5-flash')
        print("Gemini AI æ ¡æ­£æ©Ÿèƒ½ãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã—ãŸã€‚")
    except Exception as e:
        print(f"Geminiã®åˆæœŸåŒ–ã«å¤±æ•—: {e}\nAIæ ¡æ­£æ©Ÿèƒ½ã¯ç„¡åŠ¹ã§ã™ã€‚")
else:
    print("GEMINI_API_KEYãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚AIæ ¡æ­£æ©Ÿèƒ½ã¯ç„¡åŠ¹ã§ã™ã€‚")

intents = discord.Intents.default(); intents.members = True
bot = discord.Bot(intents=intents)

#--- 2. ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ç®¡ç† ---
quiz_state = {
    "is_active": False, "channel_id": None, "quiz_master_id": None,
    "correct_answer_normalized": None, "correct_answer_raw": "N/A",
    "start_time": None, "current_points": 1, "is_answering": False, "answer_log": [],
    "is_debug_mode": False, "answer_video_path": None, "is_generating": False,
}
scores, cooldowns = {}, {}
auto_end_timer_task = None

#--- 3. éåŒæœŸãƒ»ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ---
async def run_subprocess_async(command, timeout):
    return await asyncio.get_running_loop().run_in_executor(None,
        functools.partial(subprocess.run, command, check=True, capture_output=True, text=True, timeout=timeout))

def parse_and_normalize_pattern(pattern_str: str):
    normalized_parts = []
    for part in pattern_str.split(':'):
        part = part.strip().lower()
        if not part: continue
        match = re.match(r'(\d+)(?:\s*\[(.*?)\])?(o)?$', part)
        if not match: raise ValueError(f"ç„¡åŠ¹ãªãƒ‘ã‚¿ãƒ¼ãƒ³éƒ¨åˆ†: {part}")
        
        k_str, options_str, off_beat_char = match.groups()
        k = int(k_str)
        is_off_beat = (off_beat_char == 'o')
        rests, tuplets = set(), {}
        
        if options_str:
            options = [opt.strip() for opt in options_str.split(',') if opt.strip()]
            for opt in options:
                if opt.startswith('t'):
                    tuplet_match = re.match(r't(\d+)=(\d+)', opt)
                    division, beat_num = map(int, tuplet_match.groups())
                    if beat_num not in tuplets:
                        tuplets[beat_num] = {'division': division, 'rests': set()}
            for opt in options:
                r_tuplet_match = re.match(r'r=(\d+)\[(\d+)\]', opt)
                if r_tuplet_match:
                    beat_num, rest_idx = map(int, r_tuplet_match.groups())
                    if beat_num in tuplets:
                        tuplets[beat_num]['rests'].add(rest_idx)
                elif opt.startswith('r='):
                    simple_r_match = re.match(r'r=(\d+)$', opt)
                    if simple_r_match:
                        rests.add(int(simple_r_match.groups()[0]))
        
        sorted_rests = tuple(sorted(list(rests)))
        
        normalized_tuplets = []
        for beat_num, info in sorted(tuplets.items()):
            sorted_tuplet_rests = tuple(sorted(list(info['rests'])))
            normalized_tuplets.append((beat_num, (info['division'], sorted_tuplet_rests)))
        
        normalized_parts.append((k, is_off_beat, sorted_rests, tuple(normalized_tuplets)))
    
    return tuple(sorted(normalized_parts))

def validate_pattern(pattern: str):
    if any(not part.strip() for part in pattern.split(':')):
        return "':'ãŒé€£ç¶šã™ã‚‹ãªã©ã€ãƒ‘ã‚¿ãƒ¼ãƒ³æŒ‡å®šãŒç„¡åŠ¹ã§ã™ã€‚"
        
    for part in pattern.split(':'):
        part = part.strip().lower()
        match = re.match(r'(\d+)(?:\s*\[(.*?)\])?(o)?$', part)
        if not match: return f"`{part}`ã¯æœ‰åŠ¹ãªæ‹å­æŒ‡å®šã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"
        k_str, options_str, off_beat_char = match.groups()
        
        if off_beat_char and not part.endswith('o'):
             return f"è£æ‹ã‚’ç¤ºã™`o`ã¯æœ«å°¾ã«ã€‚`{part}`ã¯ç„¡åŠ¹ã§ã™ã€‚"

        k = int(k_str)
        if not (2 <= k <= 31): return f"æ‹å­æ•°ã¯2ä»¥ä¸Š31ã¾ã§ã€‚`{k}`ã¯ç„¡åŠ¹ã§ã™ã€‚"
        
        if options_str:
            processed_beats = set()
            defined_tuplets = {}
            options = [opt.strip() for opt in options_str.split(',') if opt.strip()]

            for opt in options:
                if opt.startswith('t'):
                    t_match = re.match(r't(\d+)=(\d+)', opt)
                    if not t_match: return f"é€£ç¬¦ã®æŒ‡å®š `{opt}` ãŒç„¡åŠ¹ã§ã™ã€‚"
                    division, beat = map(int, t_match.groups())
                    if not (2 <= division <= MAX_TUPLET_DIVISION): return f"é€£ç¬¦ã¯ç¾åœ¨{MAX_TUPLET_DIVISION}é€£ç¬¦ã¾ã§ã§ã™ã€‚"
                    if not (1 <= beat <= k): return f"{k}æ‹å­ã§{beat}æ‹ç›®ã¯æŒ‡å®šã§ãã¾ã›ã‚“ã€‚"
                    if beat in processed_beats: return f"{beat}æ‹ç›®ã«è¤‡æ•°ã®æŒ‡å®šã¯ã§ãã¾ã›ã‚“ã€‚"
                    processed_beats.add(beat)
                    defined_tuplets[beat] = division
            
            for opt in options:
                if opt.startswith('r='):
                    r_tuplet_match = re.match(r'r=(\d+)\[(\d+)\]', opt)
                    simple_r_match = re.match(r'r=(\d+)$', opt)

                    if r_tuplet_match:
                        beat, idx = map(int, r_tuplet_match.groups())
                        if beat not in defined_tuplets: return f"`r={beat}[{idx}]` ã‚’æŒ‡å®šã—ã¾ã—ãŸãŒã€å¯¾å¿œã™ã‚‹é€£ç¬¦(t)ã®å®šç¾©ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"
                        if not (1 <= idx <= defined_tuplets[beat]): return f"{beat}æ‹ç›®ã®{defined_tuplets[beat]}é€£ç¬¦ã«{idx}ç•ªç›®ã®éŸ³ç¬¦ã¯ãªã„ãŸã‚ã€ä¼‘ç¬¦ã«ã§ãã¾ã›ã‚“ã€‚"
                    elif simple_r_match:
                        beat = int(simple_r_match.groups()[0])
                        if not (1 <= beat <= k): return f"{k}æ‹å­ã§{beat}æ‹ç›®ã¯æŒ‡å®šã§ãã¾ã›ã‚“ã€‚"
                        if beat in processed_beats: return f"{beat}æ‹ç›®ã«ã¯æ—¢ã«é€£ç¬¦ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ä¼‘ç¬¦ã«ã§ãã¾ã›ã‚“ã€‚"
                        processed_beats.add(beat)
                    else:
                        return f"ä¼‘ç¬¦ã®æŒ‡å®š `{opt}` ãŒç„¡åŠ¹ã§ã™ã€‚"

            for opt in options:
                if not (opt.startswith('t') or opt.startswith('r=')):
                    return f"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ `{opt}` ã¯èªè­˜ã§ãã¾ã›ã‚“ã€‚"
    return None

def generate_ranking_text():
    if not scores: return "ã¾ã èª°ã‚‚ã‚¹ã‚³ã‚¢ã‚’ç²å¾—ã—ã¦ã„ã¾ã›ã‚“ã€‚"
    sorted_scores = sorted(scores.items(), key=lambda item: item[1], reverse=True)
    ranking_lines = ["**ğŸ† ç¾åœ¨ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚° ğŸ†**"]
    for i, (user_id, score) in enumerate(sorted_scores[:5]):
        user = bot.get_user(user_id)
        user_name = user.display_name if user else f"ãƒ¦ãƒ¼ã‚¶ãƒ¼({str(user_id)[-4:]})"
        ranking_lines.append(f"**{i+1}ä½**: {user_name} - {score}ãƒã‚¤ãƒ³ãƒˆ")
    return "\n".join(ranking_lines)

#--- 4 & 5. ã‚¿ã‚¹ã‚¯ ---
keep_alive = None
async def keep_alive_task():
    await bot.wait_until_ready()
    while not bot.is_closed():
        try:
            await run_subprocess_async(["python", "polyrhythm.py", "4:3", "keep_alive.png"], timeout=30)
            await asyncio.sleep(300)
        except Exception as e: await asyncio.sleep(60)

async def end_quiz_after_delay():
    await asyncio.sleep(900)
    if quiz_state["is_active"]:
        if quiz_state.get("answer_video_path") and os.path.exists(quiz_state["answer_video_path"]):
            os.remove(quiz_state["answer_video_path"])
        channel = bot.get_channel(quiz_state["channel_id"])
        if channel: await channel.send("ğŸ•’ 15åˆ†é–“æ“ä½œãŒãªã‹ã£ãŸãŸã‚ã€ã‚¯ã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ã‚’è‡ªå‹•çµ‚äº†ã—ã¾ã—ãŸã€‚")
        quiz_state["is_active"] = False

#--- 6. Botã‚¤ãƒ™ãƒ³ãƒˆ ---
@bot.event
async def on_ready():
    print(f"{bot.user} ã¨ã—ã¦ãƒ­ã‚°ã‚¤ãƒ³ã—ã¾ã—ãŸ")
    global keep_alive
    if keep_alive is None: keep_alive = bot.loop.create_task(keep_alive_task())

#--- AIæ ¡æ­£æ©Ÿèƒ½ã¨ã‚³ãƒãƒ³ãƒ‰ã®ã‚³ã‚¢ãƒ­ã‚¸ãƒƒã‚¯ ---
class ConfirmCorrectionView(discord.ui.View):
    def __init__(self, author_id, params):
        super().__init__(timeout=60)
        self.author_id = author_id
        self.params = params

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        if interaction.user.id == self.author_id:
            return True
        await interaction.response.send_message("ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ãŸæœ¬äººã—ã‹æ“ä½œã§ãã¾ã›ã‚“ã€‚", ephemeral=True)
        return False

    @discord.ui.button(label="ã¯ã„ã€ä¿®æ­£æ¡ˆã§å®Ÿè¡Œ", style=discord.ButtonStyle.green)
    async def confirm(self, button: discord.ui.Button, interaction: discord.Interaction):
        self.stop()
        await interaction.response.edit_message(content=f"âœ… ä¿®æ­£æ¡ˆã‚’é©ç”¨ã—ã¦å®Ÿè¡Œã—ã¾ã™...", view=None)
        await _execute_polyrhythm_generation(interaction, **self.params)

    @discord.ui.button(label="ã„ã„ãˆã€ã‚­ãƒ£ãƒ³ã‚»ãƒ«", style=discord.ButtonStyle.red)
    async def cancel(self, button: discord.ui.Button, interaction: discord.Interaction):
        self.stop()
        await interaction.response.edit_message(content="ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚", view=None)

async def get_ai_correction(wrong_pattern: str):
    if not genai_model: return None
    system_prompt = """
    ã‚ãªãŸã¯ã€ãƒãƒªãƒªã‚ºãƒ è¨˜æ³•ã®æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£ã™ã‚‹å°‚é–€å®¶ã§ã™ã€‚
    ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå…¥åŠ›ã—ãŸé–“é•ã£ãŸæ–‡å­—åˆ—ã‚’å—ã‘å–ã‚Šã€æ­£ã—ã„æ§‹æ–‡ã«ä¿®æ­£ã—ãŸä¸Šã§ã€ä¿®æ­£ç†ç”±ã‚’20å­—ä»¥å†…ã§ç°¡æ½”ã«èª¬æ˜ã—ã¦ãã ã•ã„ã€‚
    å‡ºåŠ›ã¯å¿…ãšä»¥ä¸‹ã®JSONå½¢å¼ã§è¿”ã—ã¦ãã ã•ã„: {"suggestion": "ä¿®æ­£å¾Œã®æ–‡å­—åˆ—", "explanation": "ä¿®æ­£ç†ç”±"}

    # æ­£ã—ã„æ§‹æ–‡ãƒ«ãƒ¼ãƒ«:
    - åŸºæœ¬å½¢: `æ‹å­æ•°:æ‹å­æ•°` (ä¾‹: `4:3`)
    - è£æ‹: `æ‹å­æ•°o` (ä¾‹: `4o`)
    - ã‚ªãƒ—ã‚·ãƒ§ãƒ³: `æ‹å­æ•°[...]` (ä¾‹: `4[r=1]`)
    - ä¼‘ç¬¦: `r=<æ‹ç•ªå·>` (ä¾‹: `r=1`)
    - é€£ç¬¦: `t<åˆ†å‰²æ•°>=<æ‹ç•ªå·>` (ä¾‹: `t3=2`)
    - é€£ç¬¦å†…ä¼‘ç¬¦: `r=<æ‹ç•ªå·>[<ãƒãƒ¼ãƒˆç•ªå·>]` (ä¾‹: `r=2[2]`)
    """
    try:
        full_prompt = system_prompt + f"\n# é–“é•ã£ãŸå…¥åŠ›:\n`{wrong_pattern}`"
        response = await genai_model.generate_content_async(full_prompt)
        cleaned_response = re.sub(r'```json\s*(.*?)\s*```', r'\1', response.text, flags=re.DOTALL).strip()
        data = json.loads(cleaned_response)
        if "suggestion" in data and "explanation" in data:
            return data
    except Exception as e:
        print(f"AIæ ¡æ­£ã‚¨ãƒ©ãƒ¼: {e}")
    return None

async def _execute_polyrhythm_generation(responder, pattern: str, mode: str, bpm: int, judge_window: bool):
    """ãƒãƒªãƒªã‚ºãƒ ç”Ÿæˆã®å®Ÿè¡Œã‚’æ‹…å½“ã™ã‚‹å…±é€šé–¢æ•°ã€‚"""
    try:
        progress_message = await responder.followup.send(f"`{pattern}` ã®ç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã™...", ephemeral=True)
        output_filename = "out.png" if mode == "image" else "out.mp4" if mode == "video" else "out.mp3"
        
        command = ["python", "polyrhythm.py", pattern, output_filename]
        if judge_window and mode == "image": command.append("--judge-window")
        if mode == "video": command.extend(["--video", f"--bpm={bpm}"])
        elif mode == "audio": command.extend(["--audio-only", f"--bpm={bpm}"])
        
        result = await run_subprocess_async(command, timeout=300)
        
        await progress_message.delete()
        with open(output_filename, "rb") as f:
            await responder.channel.send(content=f"{responder.user.mention} ã•ã‚“ã‹ã‚‰ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ:", file=discord.File(f, filename=output_filename))
            
    except Exception as e:
        stderr_message = e.stderr if hasattr(e, 'stderr') else str(e)
        # ã‚‚ã— responder.followup ãŒå¤±æ•—ã—ãŸã‚‰ã€å…ƒã®ãƒãƒ£ãƒ³ãƒãƒ«ã«ã‚¨ãƒ©ãƒ¼ã‚’é€ã‚‹
        try:
            await responder.followup.send(f"ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\n```{stderr_message}```", ephemeral=True)
        except:
            await responder.channel.send(f"{responder.user.mention} ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\n```{stderr_message}```")

#--- 7. ã‚³ãƒãƒ³ãƒ‰ ---
quiz_group = bot.create_group("quiz", "ãƒãƒªãƒªã‚ºãƒ å½“ã¦ã‚¯ã‚¤ã‚ºé–¢é€£ã®ã‚³ãƒãƒ³ãƒ‰ã§ã™ã€‚")

@quiz_group.command(name="start", description="ãƒãƒªãƒªã‚ºãƒ å½“ã¦ã‚¯ã‚¤ã‚ºã‚’é–‹å§‹ã—ã¾ã™ã€‚")
async def launch_quiz_mode(ctx):
    global scores, cooldowns, auto_end_timer_task
    await ctx.defer()
    if quiz_state["is_active"]:
        await ctx.followup.send("æ—¢ã«åˆ¥ã®ã‚¯ã‚¤ã‚ºãŒé€²è¡Œä¸­ã§ã™ï¼", ephemeral=True)
        return
    
    quiz_state.update({"is_active": True, "channel_id": ctx.channel.id, "quiz_master_id": ctx.author.id,"correct_answer_normalized": None, "is_answering": False, "answer_log": [],"is_debug_mode": False})
    scores, cooldowns = {}, {}
    if auto_end_timer_task: auto_end_timer_task.cancel()
    auto_end_timer_task = asyncio.create_task(end_quiz_after_delay())
    await ctx.followup.send(f"âœ… **ã‚¯ã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ã‚’é–‹å§‹ï¼**\nå‡ºé¡Œè€…ã¯ **{ctx.author.display_name}** ã•ã‚“ã§ã™ã€‚")

@quiz_group.command(name="end", description="ç¾åœ¨ã®ã‚¯ã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ã‚’çµ‚äº†ã—ã¾ã™ã€‚")
async def end_quiz_mode(ctx):
    global auto_end_timer_task
    await ctx.defer()
    if not quiz_state["is_active"] or ctx.author.id != quiz_state["quiz_master_id"]:
        await ctx.followup.send("ã‚¯ã‚¤ã‚ºã‚’é–‹å§‹ã—ãŸæœ¬äººã—ã‹çµ‚äº†ã§ãã¾ã›ã‚“ã€‚", ephemeral=True)
        return
    
    if quiz_state.get("is_generating", False):
        await ctx.followup.send("ç¾åœ¨ã€å•é¡Œã‚’ä½œæˆä¸­ã§ã™ã€‚å®Œäº†ã—ã¦ã‹ã‚‰çµ‚äº†ã—ã¦ãã ã•ã„ã€‚", ephemeral=True)
        return

    video_path = quiz_state.get("answer_video_path")
    if video_path and os.path.exists(video_path):
        try: os.remove(video_path)
        except Exception as e: print(f"å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ« {video_path} ã®å‰Šé™¤ã«å¤±æ•—: {e}")

    final_ranking = generate_ranking_text()
    await ctx.followup.send(f"ğŸ **ã‚¯ã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ã‚’çµ‚äº†ã—ã¾ã—ãŸï¼**\n\n{final_ranking}")
    quiz_state["is_active"] = False
    if auto_end_timer_task: auto_end_timer_task.cancel()

@quiz_group.command(name="new", description="æ–°ã—ã„ã‚¯ã‚¤ã‚ºã‚’å‡ºé¡Œã—ã¾ã™ï¼ˆå‡ºé¡Œè€…ã®ã¿ï¼‰ã€‚")
@option("pattern", description="å•é¡Œãƒ‘ã‚¿ãƒ¼ãƒ³ (ä¾‹: 4[t2=2,r=2[1]]:5o)")
@option("bpm", int, description="BPM (30-400)", min_value=30, max_value=400, default=80)
@option("points", int, description="æ­£è§£æ™‚ã«ç²å¾—ã§ãã‚‹ãƒã‚¤ãƒ³ãƒˆ", min_value=1, default=1)
async def new_quiz(ctx, pattern: str, bpm: int, points: int):
    global cooldowns, auto_end_timer_task

    if quiz_state.get("is_generating"):
        await ctx.respond("ç¾åœ¨ã€åˆ¥ã®å•é¡Œã‚’ä½œæˆä¸­ã§ã™ã€‚å®Œäº†ã¾ã§ä»Šã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚", ephemeral=True)
        return

    if not quiz_state["is_active"] or ctx.author.id != quiz_state["quiz_master_id"]:
        await ctx.respond("ã‚¯ã‚¤ã‚ºã®å‡ºé¡Œè€…ã—ã‹å•é¡Œã¯å‡ºã›ã¾ã›ã‚“ã€‚", ephemeral=True)
        return

    validation_error = validate_pattern(pattern)
    if validation_error:
        await ctx.respond(f"å…¥åŠ›ã‚¨ãƒ©ãƒ¼: {validation_error}", ephemeral=True)
        return
    
    await ctx.defer()
    quiz_state["is_generating"] = True
    try:
        output_audio, output_video = "quiz_audio.mp3", f"answer_{int(time.time())}.mp4"
        await run_subprocess_async(["python","polyrhythm.py",pattern,output_audio,"--audio-only",f"--bpm={bpm}"], timeout=60)
        
        normalized_answer = parse_and_normalize_pattern(pattern)
        parts_for_video = []
        for k, is_off, rests, tuplets in sorted(list(normalized_answer), key=lambda x: x[0], reverse=True):
            opts_list = []
            if rests: opts_list.extend([f"r={r}" for r in rests])
            if tuplets:
                for beat_num, (division, tuplet_rests) in tuplets:
                    opts_list.append(f"t{division}={beat_num}")
                    if tuplet_rests: opts_list.extend([f"r={beat_num}[{idx}]" for idx in tuplet_rests])
            
            opts_str = f"[{','.join(sorted(opts_list))}]" if opts_list else ""
            parts_for_video.append(f"{k}{opts_str}{'o' if is_off else ''}")
        video_pattern = ":".join(parts_for_video)

        await run_subprocess_async(["python","polyrhythm.py",video_pattern,output_video,"--video",f"--bpm=80"], timeout=300)

        quiz_state.update({"correct_answer_normalized": normalized_answer, "correct_answer_raw": pattern, "start_time": datetime.datetime.now(), "current_points": points, "answer_log": [], "answer_video_path": output_video,})
        cooldowns = {}
        if auto_end_timer_task: auto_end_timer_task.cancel()
        auto_end_timer_task = asyncio.create_task(end_quiz_after_delay())
        
        with open(output_audio, "rb") as f:
            await ctx.followup.send(f"**â“ æ–°ã—ã„å•é¡Œã§ã™ï¼** (BPM: {bpm} / **{points}ãƒã‚¤ãƒ³ãƒˆ**)\n`/quiz answer`ã§å›ç­”ï¼", file=discord.File(f, filename=output_audio))
    except Exception as e:
        await ctx.followup.send(f"å•é¡Œã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n```{e.stderr if hasattr(e,'stderr') else e}```")
    finally:
        quiz_state["is_generating"] = False

@quiz_group.command(name="answer", description="å‡ºé¡Œã•ã‚ŒãŸã‚¯ã‚¤ã‚ºã«å›ç­”ã—ã¾ã™ã€‚")
@option("pattern", description="ã‚ãªãŸã®å›ç­” (ä¾‹: 5:4[t2=2,r=2[1]])")
async def answering(ctx, pattern: str):
    if not quiz_state["is_active"] or quiz_state["correct_answer_normalized"] is None:
        await ctx.respond("ç¾åœ¨ã€å›ç­”ã‚’å—ã‘ä»˜ã‘ã¦ã„ã‚‹å•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚", ephemeral=True)
        return
    if ctx.author.id == quiz_state["quiz_master_id"] and not quiz_state.get("is_debug_mode", False):
        await ctx.respond("å‡ºé¡Œè€…ã¯å›ç­”ã§ãã¾ã›ã‚“ï¼", ephemeral=True)
        return
    if ctx.author.id in cooldowns and datetime.datetime.now() < cooldowns[ctx.author.id]:
        remaining = (cooldowns[ctx.author.id] - datetime.datetime.now()).seconds
        await ctx.respond(f"ãƒšãƒŠãƒ«ãƒ†ã‚£ä¸­ã§ã™ã€‚ã‚ã¨ **{remaining}ç§’** å¾…ã£ã¦ãã ã•ã„ã€‚", ephemeral=True)
        return
    if quiz_state["is_answering"]:
        await ctx.respond("ç¾åœ¨ã€åˆ¥ã®äººãŒå›ç­”ä¸­ã§ã™ã€‚å°‘ã—å¾…ã£ã¦ãã ã•ã„ï¼", ephemeral=True)
        return

    quiz_state["is_answering"] = True
    try:
        user_answer_normalized = parse_and_normalize_pattern(pattern)
    except ValueError:
        quiz_state["is_answering"] = False
        await ctx.respond("å›ç­”ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚", ephemeral=True)
        return
    
    quiz_state["answer_log"].append({"user": ctx.author.display_name, "answer": pattern, "time": datetime.datetime.now()})
    
    if user_answer_normalized == quiz_state["correct_answer_normalized"]:
        await ctx.defer()
        time_elapsed = datetime.datetime.now() - quiz_state["start_time"]
        elapsed_str = f"{time_elapsed.seconds // 60}åˆ†{time_elapsed.seconds % 60}ç§’"
        points_won = quiz_state["current_points"]
        scores[ctx.author.id] = scores.get(ctx.author.id, 0) + points_won
        
        await ctx.followup.send(f"ğŸ† **é€Ÿå ±ï¼ {ctx.author.display_name}ã•ã‚“ãŒæ­£è§£ï¼** ğŸ†\n\næ­£è§£ãƒ‘ã‚¿ãƒ¼ãƒ³: **`{quiz_state['correct_answer_raw']}`**\nè§£ç­”æ™‚é–“: {elapsed_str}\nãƒã‚¤ãƒ³ãƒˆ: **+{points_won}** ãƒã‚¤ãƒ³ãƒˆç²å¾—ï¼")
        
        video_path = quiz_state.get("answer_video_path")
        try:
            if video_path and os.path.exists(video_path):
                with open(video_path, "rb") as f:
                    ranking_text = generate_ranking_text()
                    await ctx.followup.send(f"ãŠå¾…ãŸã›ã„ãŸã—ã¾ã—ãŸï¼\nã“ã¡ã‚‰ãŒæ­£è§£ã®å‹•ç”»ã¨æœ€æ–°ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã§ã™ã€‚\n\n{ranking_text}", file=discord.File(f, filename=os.path.basename(video_path)),)
            else:
                 await ctx.followup.send("ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€ç­”ãˆã®å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚")
        finally:
            if video_path and os.path.exists(video_path): os.remove(video_path)
        quiz_state["correct_answer_normalized"] = None
        quiz_state["answer_video_path"] = None
    else:
        penalty_seconds = 20
        cooldowns[ctx.author.id] = datetime.datetime.now() + datetime.timedelta(seconds=int(penalty_seconds))
        message = f"æ®‹å¿µã€ä¸æ­£è§£ã§ã™ï¼\nã‚ãªãŸã®å›ç­”: `{pattern}`\n**{int(penalty_seconds)}ç§’é–“** ã¯å›ç­”ã§ãã¾ã›ã‚“ã€‚"
        await ctx.respond(message, ephemeral=True)
        
    quiz_state["is_answering"] = False

@quiz_group.command(name="show_answer", description="ç¾åœ¨ã®å•é¡Œã®ç­”ãˆã‚’è¡¨ç¤ºã—ã¾ã™ï¼ˆå‡ºé¡Œè€…ã®ã¿ï¼‰ã€‚")
async def show_answer(ctx):
    await ctx.defer(ephemeral=True)
    if not quiz_state["is_active"] or ctx.author.id != quiz_state["quiz_master_id"]:
        await ctx.followup.send("ã‚¯ã‚¤ã‚ºã®å‡ºé¡Œè€…ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚")
        return
    if quiz_state["correct_answer_raw"] is None or quiz_state["correct_answer_normalized"] is None:
        await ctx.followup.send("ç¾åœ¨ã€å•é¡Œã¯å‡ºé¡Œã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚")
        return
    await ctx.followup.send(f"ç¾åœ¨ã®å•é¡Œã®ç­”ãˆã¯ **`{quiz_state['correct_answer_raw']}`** ã§ã™ã€‚")

@quiz_group.command(name="peek_answers", description="æœ€æ–°ã®å›ç­”ãƒ­ã‚°5ä»¶ã‚’è¡¨ç¤ºã—ã¾ã™ï¼ˆå‡ºé¡Œè€…ã®ã¿ï¼‰ã€‚")
async def peek_answers(ctx):
    await ctx.defer(ephemeral=True)
    if not quiz_state["is_active"] or ctx.author.id != quiz_state["quiz_master_id"]:
        await ctx.followup.send("ã‚¯ã‚¤ã‚ºã®å‡ºé¡Œè€…ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚")
        return
    if not quiz_state["answer_log"]:
        await ctx.followup.send("ã¾ã èª°ã‚‚å›ç­”ã—ã¦ã„ã¾ã›ã‚“ã€‚")
        return
    log_lines = ["**ğŸ“ æœ€æ–°ã®å›ç­”ãƒ­ã‚° (æœ€å¤§5ä»¶)**"]
    for log_entry in reversed(quiz_state["answer_log"][-5:]):
        log_time = log_entry["time"].strftime("%H:%M:%S")
        log_lines.append(f"`{log_time}` **{log_entry['user']}**: `{log_entry['answer']}`")
    await ctx.followup.send("\n".join(log_lines))

@bot.slash_command(name="make_polyrhythm", description="ãƒãƒªãƒªã‚ºãƒ ã®ç”»åƒãƒ»å‹•ç”»ãƒ»éŸ³å£°ã‚’ç”Ÿæˆã—ã¾ã™ã€‚")
@option("pattern", description="ä¾‹: 7:4[t2=2,r=2[1]]")
@option("mode", str, description="ç”Ÿæˆãƒ¡ãƒ‡ã‚£ã‚¢ã‚’é¸æŠ", choices=["image", "video", "audio"], default="image")
@option("bpm", int, description="BPM (30-150)", min_value=30, max_value=150, default=80, required=False)
@option("judge_window", bool, description="åˆ¤å®šã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®è¡¨ç¤º", default=False)
async def make_polyrhythm(ctx, pattern: str, mode: str, bpm: int, judge_window: bool):
    await ctx.defer(ephemeral=True)
    
    if quiz_state["is_active"] and mode == "video":
        await ctx.followup.send("ã‚¯ã‚¤ã‚ºé€²è¡Œä¸­ã¯å‹•ç”»ç”Ÿæˆã¯ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚", ephemeral=True)
        return

    validation_error = validate_pattern(pattern)
    if validation_error:
        message = await ctx.followup.send(f"**å…¥åŠ›ã‚¨ãƒ©ãƒ¼**\n> `{validation_error}`\n\nğŸ¤– `Gemini 2.5-flash`ãŒä¿®æ­£æ¡ˆã‚’è€ƒãˆã¦ã„ã¾ã™...", ephemeral=True)
        correction = await get_ai_correction(pattern)
        
        if correction and correction["suggestion"] != pattern:
            params = {"pattern": correction["suggestion"], "mode": mode, "bpm": bpm, "judge_window": judge_window}
            view = ConfirmCorrectionView(ctx.author.id, params)
            await message.edit(
                content=f"ğŸ¤– AIã‹ã‚‰ã®ä¿®æ­£ææ¡ˆã§ã™:\n\n**ã‚‚ã—ã‹ã—ã¦:** `{correction['suggestion']}` **ã§ã™ã‹ï¼Ÿ**\n> **ç†ç”±:** {correction['explanation']}\n\nã“ã®å†…å®¹ã§å®Ÿè¡Œã—ã¾ã™ã‹ï¼Ÿ",
                view=view
            )
        else:
            await message.edit(content="ğŸ¤– AIã§ã‚‚ä¿®æ­£æ¡ˆã‚’è¦‹ã¤ã‘ã‚‰ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚å…¥åŠ›ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã”ç¢ºèªãã ã•ã„ã€‚")
        return

    await _execute_polyrhythm_generation(ctx, pattern=pattern, mode=mode, bpm=bpm, judge_window=judge_window)

@bot.slash_command(name="polyrhythm_help", description="ãƒãƒªãƒªã‚ºãƒ ã®ãƒ‘ã‚¿ãƒ¼ãƒ³è¨˜æ³•ã®ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚")
async def polyrhythm_help(ctx):
    help_text = """
    ## **ã€ğŸµ ãƒãƒªãƒªã‚ºãƒ è¨˜æ³•ã‚¬ã‚¤ãƒ‰ ğŸµã€‘**
    `/make_polyrhythm` ã‚„ `/quiz` ã§ä½¿ãˆã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ›¸ãæ–¹ã‚’èª¬æ˜ã—ã¾ã™ã€‚

    ---
    ### **1. åŸºæœ¬ã®æ›¸ãæ–¹**
    æ‹å­æ•°ã‚’ã‚³ãƒ­ãƒ³(`:`)ã§åŒºåˆ‡ã£ã¦æŒ‡å®šã—ã¾ã™ã€‚
    ```
    pattern: 4:3:5
    ```

    ---
    ### **2. è£æ‹ï¼ˆã‚ªãƒ•ãƒ“ãƒ¼ãƒˆï¼‰ `o`**
    ãƒ‘ã‚¿ãƒ¼ãƒ³å…¨ä½“ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’åŠæ‹ãšã‚‰ã—ã¾ã™ã€‚æ‹å­æŒ‡å®šã®**ä¸€ç•ªæœ€å¾Œ**ã« `o` ã‚’ä»˜ã‘ã¾ã™ã€‚
    ```
    pattern: 4o
    ```

    ---
    ### **3. ã‚ªãƒ—ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ `[...]`**
    æ‹å­æ•°ã®ç›´å¾Œã«è§’æ‹¬å¼§`[]`ã‚’ä»˜ã‘ã‚‹ã“ã¨ã§ã€ä¼‘ç¬¦ã‚„é€£ç¬¦ãªã©ã®ç´°ã‹ã„æŒ‡å®šãŒã§ãã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ã‚«ãƒ³ãƒ(`,`)ã§è¤‡æ•°æŒ‡å®šå¯èƒ½ã§ã™ã€‚

    #### **ğŸ¼ A. ä¼‘ç¬¦ `r`**
    æŒ‡å®šã—ãŸæ‹ã®éŸ³ã‚’ä¼‘ã¿ã¾ã™ã€‚ (`r` = Rest)
    > **æ›¸ãæ–¹:** `r=<æ‹ç•ªå·>`

    **ã€ä¾‹ã€‘** 8æ‹å­ã®å¶æ•°æ‹ã‚’ä¼‘ç¬¦ã«ã™ã‚‹
    ```    pattern: 8[r=2,r=4,r=6,r=8]
    ```

    #### **ğŸ¼ B. é€£ç¬¦ `t`**
    1æ‹ã‚’æŒ‡å®šã—ãŸæ•°ã§ç­‰åˆ†å‰²ã—ã¾ã™ã€‚ (`t` = Tuplet)
    > **æ›¸ãæ–¹:** `t<åˆ†å‰²æ•°>=<æ‹ç•ªå·>`
    > ï¼ˆğŸ’¡ ç¾åœ¨ã¯3é€£ç¬¦ã¾ã§å¯¾å¿œï¼‰

    **ã€ä¾‹ã€‘ã€‘** 4æ‹å­ã®2æ‹ç›®ã‚’3é€£ç¬¦ã«ã™ã‚‹
    ```
    pattern: 4[t3=2]
    ```

    ---
    ### **ğŸš€ å¿œç”¨ç·¨ï¼šç©¶æ¥µã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯**

    #### **ğŸ”§ A. åˆã‚ã›æŠ€**
    ä¼‘ç¬¦ãƒ»é€£ç¬¦ãƒ»è£æ‹ã¯ã™ã¹ã¦åŒæ™‚ã«æŒ‡å®šã§ãã¾ã™ã€‚
    **ã€ä¾‹ã€‘** 4æ‹å­ã®è£æ‹ã§ã€2æ‹ç›®ã¯3é€£ç¬¦ã€4æ‹ç›®ã¯ä¼‘ç¬¦
    ```
    pattern: 4[t3=2,r=4]o
    ```

    #### **ğŸ”§ B. é€£ç¬¦ã®ä¸­ã®ä¼‘ç¬¦**
    é€£ç¬¦ã®ç‰¹å®šã®éŸ³ã ã‘ã‚’ä¼‘ã¾ã›ã‚‹ã€æœ€ã‚‚é«˜åº¦ãªãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã§ã™ã€‚ã‚·ãƒ£ãƒƒãƒ•ãƒ«ãƒªã‚ºãƒ ãªã©ãŒä½œã‚Œã¾ã™ã€‚
    > **æ›¸ãæ–¹:** `r=<æ‹ç•ªå·>[<ãƒãƒ¼ãƒˆç•ªå·>]`

    **ã€ä¾‹ã€‘** 4æ‹å­ã®2æ‹ç›®ã‚’3é€£ç¬¦ã«ã—ã¦ã€ãã®çœŸã‚“ä¸­ã®éŸ³ã‚’ä¼‘ç¬¦ã«ã™ã‚‹
    ```
    pattern: 4[t3=2,r=2]
    ```
    """
    await ctx.respond(help_text, ephemeral=True)

bot.run(TOKEN)
PY

