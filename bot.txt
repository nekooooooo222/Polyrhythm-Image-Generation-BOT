cat > bot.py << 'PY'

import discord
from discord import option
import subprocess
import os
import datetime
from dotenv import load_dotenv
import asyncio
import functools
import re
import time

# --- 1. åˆæœŸè¨­å®š ---
ENABLE_FFMPEG_PROGRESS_LOG = True
DEBUG_PASSWORD = "polyrhythm_debug"
load_dotenv()
TOKEN = os.getenv("DISCORD_BOT_TOKEN")

if TOKEN is None:
    print("ã‚¨ãƒ©ãƒ¼: DISCORD_BOT_TOKENãŒ.envãƒ•ã‚¡ã‚¤ãƒ«ã«è¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚")
    exit()

intents = discord.Intents.default()
intents.members = True
bot = discord.Bot(intents=intents)

# --- 2. ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
quiz_state = { "is_active": False, "channel_id": None, "quiz_master_id": None, "correct_answer_sorted": None, "correct_answer_raw": "N/A", "start_time": None, "current_points": 1, "is_answering": False, "answer_log": [], "is_debug_mode": False, "answer_video_path": None, "is_generating": False, }
scores, cooldowns = {}, {}
auto_end_timer_task = None

def blocking_video_process_with_monitoring(command):
    unbuffered_command = [command[0], "-u"] + command[1:]
    
    print(f"ä»»å‹™: {' '.join(unbuffered_command)}")
    
    process = subprocess.Popen(
        unbuffered_command,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        bufsize=1
    )

    total_duration_seconds = 0
    last_logged_percent = -1
    
    duration_regex = re.compile(r"Duration: (\d{2}):(\d{2}):(\d{2})\.\d{2}")
    progress_regex = re.compile(r"frame=\s*(\d+)\s*fps=.*time=(\d{2}):(\d{2}):(\d{2})\.\d{2}") # timeã ã‘ã§ãªãframeã‚‚è¦‹ã‚‹

    for line in iter(process.stderr.readline, ''):
        line_str = line.strip()
        
        print(f"[ stderr ] {line_str}")

        if total_duration_seconds == 0:
            duration_match = duration_regex.search(line_str)
            if duration_match:
                h, m, s = map(int, duration_match.groups())
                total_duration_seconds = h * 3600 + m * 60 + s
                print(f"å‹•ç”»å†ç”Ÿæ™‚é–“:{total_duration_seconds")
                continue

        progress_match = progress_regex.search(line_str)
        if progress_match and total_duration_seconds > 0:
            frame, h, m, s = progress_match.groups()
            current_seconds = int(h) * 3600 + int(m) * 60 + float(s)
            percent = int((current_seconds / total_duration_seconds) * 100)
            
            if percent > last_logged_percent:
                last_logged_percent = percent
                print(f"é€²æ—:{percent}%...")

    process.wait()
    
    if process.returncode != 0:
        stdout_output = process.stdout.read()
        stderr_output = process.stderr.read()
        print(f"ã‚¨ãƒ©ãƒ¼:\n--- STDOUT ---\n{stdout_output}\n--- STDERR ---\n{stderr_output}")
        raise subprocess.CalledProcessError(process.returncode, command, stderr=stderr_output)
    else:
        print("æˆåŠŸ")

async def run_video_process_with_monitoring(command, timeout):
    loop = asyncio.get_running_loop()
    blocking_func = functools.partial(blocking_video_process_with_monitoring, command)
    await asyncio.wait_for(loop.run_in_executor(None, blocking_func), timeout=timeout)

async def run_subprocess_async(command, timeout):
    blocking_func = functools.partial(subprocess.run, command, check=True, capture_output=True, text=True, timeout=timeout)
    loop = asyncio.get_running_loop()
    result = await loop.run_in_executor(None, blocking_func)
    return result

# --- 3. ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ---
def parse_and_sort_answer(pattern: str): return sorted([p.strip().lower() for p in pattern.split(':') if p.strip()])
def sort_key_for_answer(item: str):
    num_str = item.replace('o', ''); return int(num_str) if num_str.isdigit() else -1
def generate_ranking_text():
    if not scores: return "ã¾ã èª°ã‚‚ã‚¹ã‚³ã‚¢ã‚’ç²å¾—ã—ã¦ã„ã¾ã›ã‚“ã€‚"
    sorted_scores = sorted(scores.items(), key=lambda item: item[1], reverse=True)
    ranking_lines = ["**ğŸ† ç¾åœ¨ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚° ğŸ†**"]
    for i, (user_id, score) in enumerate(sorted_scores[:5]):
        try:
            user = bot.get_user(user_id)
            user_name = user.display_name if user else f"ãƒ¦ãƒ¼ã‚¶ãƒ¼({str(user_id)[-4:]})"
            ranking_lines.append(f"**{i+1}ä½**: {user_name} - {score}ãƒã‚¤ãƒ³ãƒˆ")
        except: ranking_lines.append(f"**{i+1}ä½**: ä¸æ˜ãªãƒ¦ãƒ¼ã‚¶ãƒ¼ - {score}ãƒã‚¤ãƒ³ãƒˆ")
    return "\n".join(ranking_lines)

# --- 4. éåŒæœŸã‚­ãƒ¼ãƒ—ã‚¢ãƒ©ã‚¤ãƒ–ã‚¿ã‚¹ã‚¯ ---
keep_alive = None
async def keep_alive_task():
    await bot.wait_until_ready(); print("[Keep-Alive] ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—ã‚¿ã‚¹ã‚¯ã‚’é–‹å§‹ã—ã¾ã™ã€‚")
    while not bot.is_closed():
        try:
            print("[Keep-Alive] ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—å‡¦ç†ã‚’å®Ÿè¡Œä¸­...")
            command = ["python", "polyrhythm.py", "4:3", "keep_alive.png"]
            await run_subprocess_async(command, timeout=30)
            print("[Keep-Alive] ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—æˆåŠŸã€‚"); await asyncio.sleep(300)
        except asyncio.CancelledError: print("[Keep-Alive] ã‚¿ã‚¹ã‚¯ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚"); break
        except Exception as e:
            stderr = e.stderr if hasattr(e, 'stderr') else str(e)
            print(f"[Keep-Alive] ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—ä¸­ã«ã‚¨ãƒ©ãƒ¼: {stderr}"); await asyncio.sleep(60)

# --- 5. ã‚¯ã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰è‡ªå‹•çµ‚äº†ã‚¿ã‚¹ã‚¯ ---
async def end_quiz_after_delay():
    await asyncio.sleep(900)
    if quiz_state["is_active"]:
        channel = bot.get_channel(quiz_state["channel_id"])
        video_path = quiz_state.get("answer_video_path")
        if video_path and os.path.exists(video_path):
            try: os.remove(video_path); print(f"[AutoEnd] ä¸è¦ãªå‹•ç”» {video_path} ã‚’å‰Šé™¤ã€‚")
            except Exception as e: print(f"[AutoEnd] å‹•ç”»å‰Šé™¤ã«å¤±æ•—: {e}")
        if channel:
            try: await channel.send("ğŸ•’ 15åˆ†é–“æ“ä½œãŒãªã‹ã£ãŸãŸã‚ã€ã‚¯ã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ã‚’è‡ªå‹•çµ‚äº†ã—ã¾ã—ãŸã€‚")
            except discord.Forbidden: print(f"Error: Channel {quiz_state['channel_id']} ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚")
        quiz_state["is_active"] = False; print("ã‚¯ã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ã‚’è‡ªå‹•çµ‚äº†ã—ã¾ã—ãŸã€‚")

# --- 6. Botã‚¤ãƒ™ãƒ³ãƒˆ ---
@bot.event
async def on_ready():
    print(f"{bot.user} ã¨ã—ã¦ãƒ­ã‚°ã‚¤ãƒ³ã—ã¾ã—ãŸ")
    global keep_alive
    if keep_alive is None: keep_alive = bot.loop.create_task(keep_alive_task())

# --- 7. ã‚³ãƒãƒ³ãƒ‰å®šç¾© ---
quiz_group = bot.create_group("quiz", "ãƒãƒªãƒªã‚ºãƒ å½“ã¦ã‚¯ã‚¤ã‚ºé–¢é€£ã®ã‚³ãƒãƒ³ãƒ‰ã§ã™ã€‚")
@quiz_group.command(name="start", description="ãƒãƒªãƒªã‚ºãƒ å½“ã¦ã‚¯ã‚¤ã‚ºã‚’é–‹å§‹ã—ã¾ã™ã€‚")
async def launch_quiz_mode(ctx):
    global scores, cooldowns, auto_end_timer_task
    await ctx.defer()
    if quiz_state["is_active"]: await ctx.followup.send("æ—¢ã«åˆ¥ã®ã‚¯ã‚¤ã‚ºãŒé€²è¡Œä¸­ã§ã™ï¼", ephemeral=True); return
    quiz_state.update({"is_active": True, "channel_id": ctx.channel.id, "quiz_master_id": ctx.author.id, "correct_answer_sorted": None, "is_answering": False, "answer_log": [], "is_debug_mode": False})
    scores, cooldowns = {}, {}
    if auto_end_timer_task: auto_end_timer_task.cancel()
    auto_end_timer_task = asyncio.create_task(end_quiz_after_delay())
    await ctx.followup.send(f"âœ… **ã‚¯ã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ã‚’é–‹å§‹ï¼**\nå‡ºé¡Œè€…ã¯ **{ctx.author.display_name}** ã•ã‚“ã§ã™ã€‚")

@quiz_group.command(name="end", description="ç¾åœ¨ã®ã‚¯ã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ã‚’çµ‚äº†ã—ã¾ã™ã€‚")
async def end_quiz_mode(ctx):
    global auto_end_timer_task
    await ctx.defer()
    if not quiz_state["is_active"] or ctx.author.id != quiz_state["quiz_master_id"]: await ctx.followup.send("ã‚¯ã‚¤ã‚ºã‚’é–‹å§‹ã—ãŸæœ¬äººã—ã‹çµ‚äº†ã§ãã¾ã›ã‚“ã€‚", ephemeral=True); return
    if quiz_state.get("is_generating", False): await ctx.followup.send("ç¾åœ¨ã€å•é¡Œã‚’ä½œæˆä¸­ã§ã™ã€‚å®Œäº†ã—ã¦ã‹ã‚‰çµ‚äº†ã—ã¦ãã ã•ã„ã€‚", ephemeral=True); return
    video_path = quiz_state.get("answer_video_path")
    if video_path and os.path.exists(video_path):
        try: os.remove(video_path); print(f"ä¸è¦ã«ãªã£ãŸå‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ« {video_path} ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚")
        except Exception as e: print(f"å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ« {video_path} ã®å‰Šé™¤ã«å¤±æ•—: {e}")
    final_ranking = generate_ranking_text()
    await ctx.followup.send(f"ğŸ **ã‚¯ã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ã‚’çµ‚äº†ã—ã¾ã—ãŸï¼**\n\n{final_ranking}")
    quiz_state["is_active"] = False
    if auto_end_timer_task: auto_end_timer_task.cancel()

@quiz_group.command(name="new", description="æ–°ã—ã„ã‚¯ã‚¤ã‚ºã‚’å‡ºé¡Œã—ã¾ã™ï¼ˆå‡ºé¡Œè€…ã®ã¿ï¼‰ã€‚")
@option("pattern", description="å•é¡Œã¨ãªã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ (ä¾‹: 7:5:3o)")
@option("bpm", int, description="å•é¡Œã®BPM (ãƒ†ãƒ³ãƒ)", min_value=30, max_value=150, default=80)
@option("points", int, description="æ­£è§£æ™‚ã«ç²å¾—ã§ãã‚‹ãƒã‚¤ãƒ³ãƒˆ", min_value=1, default=1)
async def new_quiz(ctx, pattern: str, bpm: int, points: int):
    global cooldowns, auto_end_timer_task
    await ctx.defer()
    if quiz_state.get("is_generating", False): await ctx.followup.send("ç¾åœ¨ã€åˆ¥ã®å•é¡Œã‚’ä½œæˆä¸­ã§ã™ã€‚å®Œäº†ã¾ã§ä»Šã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚", ephemeral=True); return
    if not quiz_state["is_active"] or ctx.author.id != quiz_state["quiz_master_id"]: await ctx.followup.send("ã‚¯ã‚¤ã‚ºã®å‡ºé¡Œè€…ã—ã‹å•é¡Œã¯å‡ºã›ã¾ã›ã‚“ã€‚", ephemeral=True); return
    if pattern == DEBUG_PASSWORD:
        current_state = quiz_state.get("is_debug_mode", False); quiz_state["is_debug_mode"] = not current_state
        status = "æœ‰åŠ¹" if quiz_state["is_debug_mode"] else "ç„¡åŠ¹"; await ctx.followup.send(f"ğŸ› ï¸ **ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’ã€{status}ã€‘ã«åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸã€‚**", ephemeral=True); return
    quiz_state["is_generating"] = True
    try:
        await ctx.followup.send("æ–°ã—ã„å•é¡Œã‚’ä½œæˆä¸­ã§ã™â€¦ éŸ³å£°ã¨**ç­”ãˆã®å‹•ç”»**ã‚’æº–å‚™ã—ã¦ã„ã¾ã™ã€‚", ephemeral=True)
        cooldowns = {}; output_audio = "quiz_audio.mp3"; output_video = f"answer_{int(time.time())}.mp4"
        cmd_audio = ["python", "polyrhythm.py", pattern, output_audio, "--audio-only", f"--bpm={bpm}"]
        await run_subprocess_async(cmd_audio, timeout=60)
        sorted_list = sorted(parse_and_sort_answer(pattern), key=sort_key_for_answer, reverse=True)
        video_pattern = ":".join(sorted_list)
        cmd_video = ["python", "polyrhythm.py", video_pattern, output_video, "--video", f"--bpm=80"]
        if ENABLE_FFMPEG_PROGRESS_LOG: await run_video_process_with_monitoring(cmd_video, timeout=300)
        else: await run_subprocess_async(cmd_video, timeout=300)
        quiz_state.update({"correct_answer_sorted": parse_and_sort_answer(pattern), "correct_answer_raw": pattern, "start_time": datetime.datetime.now(), "current_points": points, "answer_log": [], "answer_video_path": output_video,})
        if auto_end_timer_task: auto_end_timer_task.cancel()
        auto_end_timer_task = asyncio.create_task(end_quiz_after_delay())
        with open(output_audio, "rb") as f: await ctx.followup.send(f"**â“ æ–°ã—ã„å•é¡Œã§ã™ï¼** (BPM: {bpm} / **{points}ãƒã‚¤ãƒ³ãƒˆ**)\n`/quiz answer`ã§å›ç­”ï¼", file=discord.File(f, filename=output_audio))
    except Exception as e:
        stderr_message = e.stderr if hasattr(e, 'stderr') else str(e)
        await ctx.followup.send(f"ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€å•é¡Œã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n```{stderr_message}```")
    finally: quiz_state["is_generating"] = False

@quiz_group.command(name="answer", description="å‡ºé¡Œã•ã‚ŒãŸã‚¯ã‚¤ã‚ºã«å›ç­”ã—ã¾ã™ã€‚")
@option("pattern", description="ã‚ãªãŸã®å›ç­” (ä¾‹: 3o:7:5)")
async def answering(ctx, pattern: str):
    if not quiz_state["is_active"] or quiz_state["correct_answer_sorted"] is None: await ctx.respond("ç¾åœ¨ã€å›ç­”ã‚’å—ã‘ä»˜ã‘ã¦ã„ã‚‹å•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚", ephemeral=True); return
    if ctx.author.id == quiz_state["quiz_master_id"] and not quiz_state.get("is_debug_mode", False): await ctx.respond("å‡ºé¡Œè€…ã¯å›ç­”ã§ãã¾ã›ã‚“ï¼", ephemeral=True); return
    if ctx.author.id in cooldowns and datetime.datetime.now() < cooldowns[ctx.author.id]:
        remaining = (cooldowns[ctx.author.id] - datetime.datetime.now()).seconds
        await ctx.respond(f"ãƒšãƒŠãƒ«ãƒ†ã‚£ä¸­ã§ã™ã€‚ã‚ã¨ **{remaining}ç§’** å¾…ã£ã¦ãã ã•ã„ã€‚", ephemeral=True); return
    if quiz_state["is_answering"]: await ctx.respond("ç¾åœ¨ã€åˆ¥ã®äººãŒå›ç­”ä¸­ã§ã™ã€‚å°‘ã—å¾…ã£ã¦ãã ã•ã„ï¼", ephemeral=True); return
    quiz_state["is_answering"] = True
    quiz_state["answer_log"].append({"user": ctx.author.display_name, "answer": pattern, "time": datetime.datetime.now()})
    user_answer_sorted = parse_and_sort_answer(pattern)
    if user_answer_sorted == quiz_state["correct_answer_sorted"]:
        await ctx.defer()
        time_elapsed = datetime.datetime.now() - quiz_state["start_time"]; elapsed_str = f"{time_elapsed.seconds // 60}åˆ†{time_elapsed.seconds % 60}ç§’"
        points_won = quiz_state["current_points"]; scores[ctx.author.id] = scores.get(ctx.author.id, 0) + points_won
        await ctx.followup.send(f"ğŸ† **é€Ÿå ±ï¼ {ctx.author.display_name}ã•ã‚“ãŒæ­£è§£ï¼** ğŸ†\n\næ­£è§£ãƒ‘ã‚¿ãƒ¼ãƒ³: **`{quiz_state['correct_answer_raw']}`**\nè§£ç­”æ™‚é–“: {elapsed_str}\nãƒã‚¤ãƒ³ãƒˆ: **+{points_won}** ãƒã‚¤ãƒ³ãƒˆç²å¾—ï¼")
        video_path = quiz_state.get("answer_video_path")
        try:
            if video_path and os.path.exists(video_path):
                with open(video_path, "rb") as f:
                    ranking_text = generate_ranking_text()
                    await ctx.followup.send(f"ãŠå¾…ãŸã›ã„ãŸã—ã¾ã—ãŸï¼\nã“ã¡ã‚‰ãŒæ­£è§£ã®å‹•ç”»ã¨æœ€æ–°ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã§ã™ã€‚\n\n{ranking_text}", file=discord.File(f, filename=os.path.basename(video_path)),)
            else: await ctx.followup.send("ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€ç­”ãˆã®å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚")
        finally:
            if video_path and os.path.exists(video_path): os.remove(video_path)
        quiz_state["correct_answer_sorted"] = None; quiz_state["answer_video_path"] = None
    else:
        penalty_seconds = 20; is_handicap_target = False
        if scores and ctx.author.id in scores:
            sorted_scores_tuples = sorted(scores.items(), key=lambda item: item[1], reverse=True); sorted_scores_list = [s for u, s in sorted_scores_tuples]; num_players = len(sorted_scores_tuples)
            player_rank = -1
            for i, (uid, s) in enumerate(sorted_scores_tuples):
                if uid == ctx.author.id: player_rank = i; break
            is_solo_first = (player_rank == 0 and (num_players == 1 or sorted_scores_tuples[0][1] > sorted_scores_tuples[1][1]))
            if is_solo_first:
                is_handicap_target = True; p1_score = sorted_scores_list[0]; p2_score = sorted_scores_list[1] if num_players > 1 else 0; sum_lower_scores = sum(sorted_scores_list[1:])
                if p2_score == 0 or sum_lower_scores <= 5: p1_handicap = 20 + p1_score * 4
                else:
                    p2_to_5_scores = sum(sorted_scores_list[1:5]); denominator = p2_to_5_scores + p2_score
                    if denominator > 0: factor = (p1_score / (denominator / num_players)) * 0.8; p1_handicap = 20 * factor
                    else: p1_handicap = 20
                penalty_seconds = max(min(p1_handicap, 50), 20)
            elif player_rank == 1:
                p1_score = sorted_scores_list[0]; p2_score = sorted_scores_list[1]
                if p1_score < p2_score * 1.4:
                    is_handicap_target = True; p1_temp_handicap = 20; p1_p2_score = sorted_scores_list[1]; p1_sum_lower = sum(sorted_scores_list[1:])
                    if p1_p2_score == 0 or p1_sum_lower <= 5: p1_temp_handicap = 20 + p1_score * 4
                    else:
                        p1_p2_to_5 = sum(sorted_scores_list[1:5]); p1_denom = p1_p2_to_5 + p1_p2_score
                        if p1_denom > 0: p1_factor = (p1_score / (p1_denom / num_players)) * 1; p1_temp_handicap = 20 * p1_factor
                    final_p1_handicap = max(min(p1_temp_handicap, 50), 20); p3_to_6_scores = sorted_scores_list[2:6]
                    avg_p3_to_6 = sum(p3_to_6_scores) / len(p3_to_6_scores) if p3_to_6_scores else 0; calculated_p2_handicap = 0
                    if avg_p3_to_6 > 0: calculated_p2_handicap = 20 * ((p2_score / avg_p3_to_6) * 0.7)
                    capped_p2_handicap = max(min(calculated_p2_handicap, 35), 20); p1_related_limit = max(final_p1_handicap - 5, 20)
                    penalty_seconds = min(capped_p2_handicap, p1_related_limit)
        cooldowns[ctx.author.id] = datetime.datetime.now() + datetime.timedelta(seconds=int(penalty_seconds))
        message = f"æ®‹å¿µã€ä¸æ­£è§£ã§ã™ï¼\nã‚ãªãŸã®å›ç­”: `{pattern}`\n"
        if is_handicap_target: message += f"**ãƒãƒ³ãƒ‡é©ç”¨ï¼** **{int(penalty_seconds)}ç§’é–“** ã¯å›ç­”ã§ãã¾ã›ã‚“ã€‚"
        else: message += f"**{int(penalty_seconds)}ç§’é–“** ã¯å›ç­”ã§ãã¾ã›ã‚“ã€‚"
        await ctx.respond(message, ephemeral=True)
    quiz_state["is_answering"] = False

@quiz_group.command(name="show_answer", description="ç¾åœ¨ã®å•é¡Œã®ç­”ãˆã‚’è¡¨ç¤ºã—ã¾ã™ï¼ˆå‡ºé¡Œè€…ã®ã¿ï¼‰ã€‚")
async def show_answer(ctx):
    await ctx.defer(ephemeral=True)
    if not quiz_state["is_active"] or ctx.author.id != quiz_state["quiz_master_id"]: await ctx.followup.send("ã‚¯ã‚¤ã‚ºã®å‡ºé¡Œè€…ã®ã¿ä½¿ç”¨ã§ãã¾ã™."); return
    if quiz_state["correct_answer_raw"] is None or quiz_state["correct_answer_sorted"] is None: await ctx.followup.send("ç¾åœ¨ã€å•é¡Œã¯å‡ºé¡Œã•ã‚Œã¦ã„ã¾ã›ã‚“."); return
    await ctx.followup.send(f"ç¾åœ¨ã®å•é¡Œã®ç­”ãˆã¯ **`{quiz_state['correct_answer_raw']}`** ã§ã™ã€‚")

@quiz_group.command(name="peek_answers", description="æœ€æ–°ã®å›ç­”ãƒ­ã‚°5ä»¶ã‚’è¡¨ç¤ºã—ã¾ã™ï¼ˆå‡ºé¡Œè€…ã®ã¿ï¼‰ã€‚")
async def peek_answers(ctx):
    await ctx.defer(ephemeral=True)
    if not quiz_state["is_active"] or ctx.author.id != quiz_state["quiz_master_id"]: await ctx.followup.send("ã‚¯ã‚¤ã‚ºã®å‡ºé¡Œè€…ã®ã¿ä½¿ç”¨ã§ãã¾ã™."); return
    if not quiz_state["answer_log"]: await ctx.followup.send("ã¾ã èª°ã‚‚å›ç­”ã—ã¦ã„ã¾ã›ã‚“."); return
    log_lines = ["**ğŸ“ æœ€æ–°ã®å›ç­”ãƒ­ã‚° (æœ€å¤§5ä»¶)**"]
    for log_entry in reversed(quiz_state["answer_log"][-5:]):
        log_time = log_entry["time"].strftime("%H:%M:%S"); log_lines.append(f"`{log_time}` **{log_entry['user']}**: `{log_entry['answer']}`")
    await ctx.followup.send("\n".join(log_lines))

@bot.slash_command(name="make_polyrhythm", description="ãƒãƒªãƒªã‚ºãƒ ã®ç”»åƒãƒ»å‹•ç”»ãƒ»éŸ³å£°ã‚’ç”Ÿæˆã—ã¾ã™ã€‚")
@option("pattern", description="ä¾‹: 7:5:3o 2-31æ‹å­ã¾ã§")
@option("mode", str, description="ç”Ÿæˆãƒ¡ãƒ‡ã‚£ã‚¢ã‚’é¸æŠ", choices=["image", "video", "audio"], default="image")
@option("bpm", int, description="BPM (30-150)", min_value=30, max_value=150, default=80, required=False)
@option("judge_window", bool, description="åˆ¤å®šã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®è¡¨ç¤º", default=False)
async def make_polyrhythm(ctx, pattern: str, mode: str, bpm: int, judge_window: bool):
    await ctx.defer()
    if quiz_state["is_active"] and mode == "video": await ctx.followup.send("ã‚¯ã‚¤ã‚ºé€²è¡Œä¸­ã¯ã€è² è·ã®é«˜ã„**å‹•ç”»ç”Ÿæˆ**ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚", ephemeral=True); return
    pattern_parts = pattern.split(':'); invalid_pattern = False
    if any(not part.strip() for part in pattern_parts): invalid_pattern = "`:`ãŒé€£ç¶šãªã©ã€ãƒ‘ã‚¿ãƒ¼ãƒ³æŒ‡å®šãŒç„¡åŠ¹ã§ã™ã€‚"
    if not invalid_pattern:
        for part in pattern_parts:
            part = part.strip().lower()
            if '.' in part: invalid_pattern = f"`{part}`ã«å°æ•°ç‚¹ãŒä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚"; break
            if 'o' in part and not part.endswith('o'): invalid_pattern = f"è£æ‹ã‚’ç¤ºã™`o`ã¯æ•°å­—ã®æœ€å¾Œã«ã€‚`{part}`ã¯ç„¡åŠ¹ã§ã™ã€‚"; break
            if part.count('o') > 1: invalid_pattern = f"`{part}`ã«`o`ãŒè¤‡æ•°ã‚ã‚Šã¾ã™ã€‚"; break
            num_str = part.removesuffix('o')
            if not num_str.isdigit(): invalid_pattern = f"`{part}`ã¯æœ‰åŠ¹ãªæ‹å­æŒ‡å®šã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"; break
            num = int(num_str)
            if num < 2: invalid_pattern = f"æ‹å­ã¯2ä»¥ä¸Šã§ã€‚`{part}`ã¯ç„¡åŠ¹ã§ã™ã€‚"; break
            if num > 31: invalid_pattern = f"æ‹å­æ•°ã¯31ã¾ã§ã€‚`{part}`ã¯ç„¡åŠ¹ã§ã™ã€‚"; break
    if invalid_pattern: await ctx.followup.send(invalid_pattern, ephemeral=True); return
    if mode == "image": output_filename = "out.png"
    elif mode == "video": output_filename = "out.mp4"
    else: output_filename = "out.mp3"
    try:
        command = ["python", "polyrhythm.py", pattern, output_filename]
        if judge_window: command.append("--judge-window")
        if mode == "video": command.extend(["--video", f"--bpm={bpm}"])
        elif mode == "audio": command.extend(["--audio-only", f"--bpm={bpm}"])
        print(f"å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰: {' '.join(command)}")
        if mode == "video" and ENABLE_FFMPEG_PROGRESS_LOG:
            await run_video_process_with_monitoring(command, timeout=300)
        else:
            result = await run_subprocess_async(command, timeout=300)
            if result.stdout: print(f"--- polyrhythm.py stdout ---\n{result.stdout}\n--------------------------")
            if result.stderr: print(f"--- polyrhythm.py stderr ---\n{result.stderr}\n--------------------------")
        with open(output_filename, "rb") as f:
            await ctx.followup.send(file=discord.File(f, filename=output_filename))
    except Exception as e:
        stderr_message = e.stderr if hasattr(e, 'stderr') else str(e)
        print(f"ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼: {stderr_message}")
        await ctx.followup.send(f"ã”ã‚ã‚“ãªã•ã„ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\n```{stderr_message}```", ephemeral=True)

bot.run(TOKEN)
PY